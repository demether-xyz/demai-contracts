// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Vm} from "forge-std/Vm.sol";

contract DirectAkkaSwap is Script {
    // --- Chain & Token Addresses (Core) ---
    address constant USDC = 0xa4151B2B3e269645181dCcF2D426cE75fcbDeca9;
    address constant SOLVBTC = 0x9410e8052Bc661041e5cB27fDf7d9e9e842af2aa;

    // File containing the swap data generated by the Python script
    string constant DATA_FILE = "scripts/swap_data.txt";

    function run() external {
        console.log("=== Executing Direct Akka Swap on Core ===");

        // --- Read Swap Data from File ---
        string memory fileContent = vm.readFile(DATA_FILE);
        string[] memory lines = vm.split(fileContent, '\n');
        string memory amountInStr = lines[0];
        string memory routerAddressStr = lines[1];
        string memory calldataStr = lines[2];

        uint256 amountIn = vm.parseUint(amountInStr);
        address akkaRouter = vm.parseAddress(routerAddressStr);
        bytes memory calldataToExecute = vm.parseBytes(calldataStr);

        console.log("Read from file:");
        console.log(" - Amount In:", amountIn);
        console.log(" - Router Address:", akkaRouter);
        console.log(" - Calldata Length:", calldataToExecute.length);

        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address manager = vm.addr(deployerPrivateKey);
        console.log("Manager Address:", manager);

        vm.startBroadcast(deployerPrivateKey);

        // --- Check Initial Balances ---
        uint256 usdcBalanceBefore = IERC20(USDC).balanceOf(manager);
        uint256 solvBtcBalanceBefore = IERC20(SOLVBTC).balanceOf(manager);
        console.log("USDC balance before swap:", usdcBalanceBefore);
        console.log("solvBTC balance before swap:", solvBtcBalanceBefore);

        // --- Validate we have enough USDC ---
        require(usdcBalanceBefore >= amountIn, "Insufficient USDC balance");

        // --- Step 1: Approve Router ---
        console.log("Approving Akka router to spend USDC...");
        IERC20(USDC).approve(akkaRouter, amountIn);

        // --- Step 2: Execute Swap ---
        console.log("Executing swap on Akka router...");
        
        // Check if we have valid calldata
        if (calldataToExecute.length == 0) {
            console.log("WARNING: Empty calldata detected - this is a test run");
            console.log("In a real scenario, you would:");
            console.log("1. Approve the router (DONE)");
            console.log("2. Call the Akka API /swap endpoint to get real calldata");
            console.log("3. Execute the swap with the real calldata");
            
            // For testing, let's just verify the approval worked
            uint256 allowance = IERC20(USDC).allowance(manager, akkaRouter);
            console.log("Verified allowance:", allowance);
            require(allowance >= amountIn, "Approval failed");
            
            console.log("SUCCESS: Test successful - Approval flow working correctly");
            vm.stopBroadcast();
            return;
        }

        // Execute the actual swap call
        (bool success, bytes memory returnData) = akkaRouter.call(calldataToExecute);
        
        if (!success) {
            console.log("ERROR: Swap call failed");
            if (returnData.length > 0) {
                console.log("Error data length:", returnData.length);
                // Try to decode the error
                assembly {
                    let returnDataSize := mload(returnData)
                    revert(add(32, returnData), returnDataSize)
                }
            } else {
                revert("Swap call failed with no error data");
            }
        }

        // --- Verify Results ---
        uint256 usdcBalanceAfter = IERC20(USDC).balanceOf(manager);
        uint256 solvBtcBalanceAfter = IERC20(SOLVBTC).balanceOf(manager);
        
        console.log("USDC balance after swap:", usdcBalanceAfter);
        console.log("solvBTC balance after swap:", solvBtcBalanceAfter);

        // Verify the swap actually happened
        require(usdcBalanceAfter < usdcBalanceBefore, "USDC balance should decrease");
        require(solvBtcBalanceAfter > solvBtcBalanceBefore, "solvBTC balance should increase");

        console.log("SUCCESS: Swap successful!");
        console.log("USDC spent:", usdcBalanceBefore - usdcBalanceAfter);
        console.log("solvBTC received:", solvBtcBalanceAfter - solvBtcBalanceBefore);

        vm.stopBroadcast();
    }
} 